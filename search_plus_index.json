{"./":{"url":"./","title":"介绍","keywords":"","body":"介绍 本文档旨在规范团队中成员的代码风格，以达成团队中成员高效协作的目的。 不足之处，还望指出。本文档会持续更新。 在线访问地址 "},"CHANGELOG.html":{"url":"CHANGELOG.html","title":"更新日志","keywords":"","body":"版本更新日志 v1.0.0 搭了基本的book机构，写了前端API适配层规范 v1.1.0 新增了前端项目目录结构及文件命名规范 v1.2.0 新增了Javascript编码规范和Vue编码规范，待完善！ v1.2.1 完善了Javascript编码规范 v1.2.2 更新了Vue编码规范 "},"项目目录结构规范.html":{"url":"项目目录结构规范.html","title":"前端项目目录结构及文件命名规范","keywords":"","body":"概述 本文简单描述了前端项目中目录及文件的结构和命名规范。 目录结构 现在前端都是工程化的天下，一般而言，会将整个项目分为源代码和工程配置两部分。源代码应放在/src目录下，而工程配置则一般直接放在项目根目录/下，如webpack, gulp, eslint, babel, postcss, .gitignore， package.json等配置。对于较复杂的工程配置如webpack，我们还会单独给其建一个目录build。 所以大概的目录结构会是这样： │ .babelrc │ .editorconfig │ .eslintignore │ .eslintrc.js │ .gitignore │ .postcssrc.js │ favicon.ico │ index.html │ package-lock.json │ package.json │ ├─.vscode │ settings.json │ ├─build │ build-test.js │ build.js │ check-versions.js │ utils.js │ vue-loader.conf.js │ webpack.base.conf.js │ webpack.dev.conf.js │ webpack.prod.conf.js │ webpack.test.conf.js │ ├─config │ dev.env.js │ index.js │ prod.env.js │ test.env.js │ ├─src │ │ App.vue │ │ main.js │ │ 命名 统一使用kebab-case（短横线）命令法来命名文件夹及文件。如common-utils, build-config。 使用短横线用来分隔单词，能让使用者快速提取关键单词，保证易理解性。 现在很多npm包广泛采用了kebab-case（短横线）命令法。 var gitalk = new Gitalk({ clientID: \"abe61bb2112d4926d0b9\", clientSecret: \"760737a207de2813a6586e1d2c14dd187ddeea64\", repo: \"FE-guide\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"前端API适配层规范.html":{"url":"前端API适配层规范.html","title":"前端API适配层规范","keywords":"","body":"概述 为了满足统一性和规范性，体现语义化的原则，我对前端的接口适配层提出了一种约束方式，基本上是符合RESTful API的原则的。 微服务架构 首先，为了对齐后端微服务架构，在前端将API调用分为三个模块。 ├─base 负责调用basecenterweb服务 ├─eqp 负责调用eqpcenterweb服务 └─user 负责调用ucenterweb服务 每个模块下都定义了统一的微服务命名空间，例如/src/api/base/index.js： export const namespace = 'basecenterweb'; 特性案例 每个功能特性都有独立的js模块，以角色管理相关接口为例，路径是/src/api/user/role.js import api from '../api' import { rejectNull } from \"../../utils/helper\"; import { namespace } from \"./index\" // 特性命名空间 const feature = 'role' // 添加 export const addRole = params => api.post(`/${namespace}/${feature}/add`, rejectNull(params)); // 删除 export const deleteRole = params => api.deletes(`/${namespace}/${feature}/delete`, params); // 更新 export const updateRole = params => api.put(`/${namespace}/${feature}/update`, rejectNull(params)); // 条件查询 export const findRoles = params => api.get(`/${namespace}/${feature}/find`, params); // 查询所有记录 export const getAllRoles = () => findRoles(); // 获取详情 export const getRoleDetail = params => api.get(`/${namespace}/${feature}/detail`, params); // 分页 export const getRolePage = params => api.get(`/${namespace}/${feature}/page`, rejectNull(params)); // 搜索 export const searchRole = params => params.wd ? api.get(`/${namespace}/${feature}/search`, rejectNull(params)) : getRolePage(params); 每一条接口都根据RESTful风格，调用增（api.post）删（api.deletes）改（api.put）查（api.get）的底层方法。 调用的url由三部分组成，格式：/微服务命名空间/特性命名空间/方法 接口适配层函数命名规范： 新增：addXXX 删除：deleteXXX 更新：updateXXX 根据ID查询记录：getXXXDetail 条件查询一条记录：findOneXXX 条件查询：findXXXs 查询所有记录：getAllXXXs 分页查询：getXXXPage 搜索：searchXXX 注：请按照以上规范执行，让接口维护变得简单。 var gitalk = new Gitalk({ clientID: \"abe61bb2112d4926d0b9\", clientSecret: \"760737a207de2813a6586e1d2c14dd187ddeea64\", repo: \"FE-guide\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"HTML编码规范.html":{"url":"HTML编码规范.html","title":"HTML编码规范","keywords":"","body":"HTML编码规范 TODO var gitalk = new Gitalk({ clientID: \"abe61bb2112d4926d0b9\", clientSecret: \"760737a207de2813a6586e1d2c14dd187ddeea64\", repo: \"FE-guide\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"CSS编码规范.html":{"url":"CSS编码规范.html","title":"CSS编码规范","keywords":"","body":"CSS编码规范 TODO var gitalk = new Gitalk({ clientID: \"abe61bb2112d4926d0b9\", clientSecret: \"760737a207de2813a6586e1d2c14dd187ddeea64\", repo: \"FE-guide\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"Javascript编码规范.html":{"url":"Javascript编码规范.html","title":"Javascript编码规范","keywords":"","body":"概述 本文根据生产实践和一些行业内的规范，总结了适合前端团队的javascript编码风格，为团队成员提供编码风格标准和参考依据，规则不是固定的，最终以实际项目中lint规则为准！ 文件夹及文件命名 统一使用kebab-case（短横线）命名法来命名文件夹及文件，见前端项目目录结构及文件命名规范。 命名规范 命名应具备语义化的基本原则，禁止使用无具体含义的命名。 // good let age = 18; let sex = '男'; // bad let var1 = 18; let s = '男'; 禁止采用保留关键字进行命名，可参考ES5注解 Reserved Words，如果不确定是不是关键字，则采用单词组合的方式增强命名。 // good let defaultValue = 1; // bad let default = 1; 常量 全部采用大写，单词间用下划线_分隔。系统中常量应该尽量统一维护在某个固定文件中，如/src/utils/const.js，当然也可视业务而定进行适当分离。 // good export const BSJ_CUSTOMER_KEY = 'fa1ceced-70ec-4717-8a09-6174cffd2b5f' // bad export const BSJCUSTOMERKEY = 'fa1ceced-70ec-4717-8a09-6174cffd2b5f' 变量 采用小驼峰（Lower Camel Case）写法。 // good let userName = 'Tusi' // bad let UserName = 'Tusi' 对于引用类型（Array或Object），请使用const定义，而不要使用var或let，防止变量被重新赋值而导致意料之外的bug。 // good const options = { startTime: '2018', endTime: '2019' } // bad let options = { startTime: '2018', endTime: '2019' } 函数命名 普通函数采用小驼峰（Lower Camel Case）写法，并采用动宾结构进行命名，如： // good function getUserInfo() {} function addUser() {} // bad function userinfo() {} function add() {} 构造函数采用大驼峰（Upper Camel Case）写法，也称之为Pascal Case。 // good function User() {} let userInstance = new User(); // bad function user() {} let userInstance = new user(); 类命名 采用大驼峰（Upper Camel Case）写法。 代码风格 缩进 配置时，统一采用4空格缩进风格，禁止使用制表符tab缩进。如若遇见缩进设置有误的文件，可参考VSCode缩进方式转换。 操作时，仍使用tab键缩进，根据配置，已默认执行了tab转space 空格 【强制】操作符前后保留一个空格，包括赋值运算符，算术运算符，比较运算符，逻辑运算符，条件运算符（三元运算符）等。 // \"space-infix-ops\": 2 // good let result = 1 + 2; // bad let result = 1+2; 【强制】禁止出现多余的空格。 // 'no-multi-spaces': 2 // good let result = 1 + 2; // bad let result = 1 + 2; 【强制】函数圆括号之前不加空格，圆括号之后加一个空格。 // \"space-before-function-paren\": [2, \"nerver\"] // \"space-before-blocks\": [2, 'always'] // good function login(params) { // ... } // bad function login(params){ } 【强制】关键字前后各一个空格，例如if, switch, for等常用关键字。 // 'keyword-spacing': [2, { before: true, after: true }] // good if (bool) { //... } else { //... } // bad if(bool) { //... } else{ //... } if (bool) { //... }else { //... } 【强制】花括号开始后和结束前有空格 // 'block-spacing': [2, 'always'] // good function getBool() { return true; } // bad function getBool() {return true;} 【强制】逗号，分号前无空格，后有空格 // \"semi-spacing\": [2, {\"before\": false, \"after\": true}] // good [1, 2] var name; var sex; // bad [1 , 2] [1,2] [1 ,2] var name;var sex; 【强制】箭头函数的箭头之前和之后有空格 // 'arrow-spacing': [2, { before: true, after: true }] // good promiseTask.then(res => { // ... }) // bad promiseTask.then(res=> { // ... }) promiseTask.then(res =>{ // ... }) 【强制】在对象字面量、解构赋值 和import/export的花括号中使用一致的空格。若对象最后一个元素是对象或数组，则结束花括号前不需要空格。 // 'object-curly-spacing': [2, 'always', { objectsInObjects: false, \"arraysInObjects\": false }] // good let obj = { name: 'Tusi', sex: '男' } let { name, sex } = { name: 'Tusi', sex: '男' } let newObj = { name: 'Tusi', sex: '男', moreInfo: { salary: 1 }} import { merge } from \"utils\" // bad let obj = {name: 'Tusi', sex: '男' } let { name, sex} = { name: 'Tusi', sex: '男' } let newObj = { name: 'Tusi', sex: '男', moreInfo: { salary: 1} } import { merge} from \"utils\" 【强制】数组内部除逗号后有空格外，禁止出现其他空格 // 'array-bracket-spacing': [2, 'never'] // good let nameArr = ['Tusi', '张三', '李四'] // bad let nameArr = [ 'Tusi', '张三', '李四' ] 【强制】冒号前无空格，冒号后有空格，适用于case，对象键值对等。 // \"switch-colon-spacing\": [2, {\"after\": true, \"before\": false}] // 'key-spacing': [2, { beforeColon: false, afterColon: true, mode: 'strict' }] // good switch (age) { case 18: break; default: break; } let obj = { name: 'Tusi', sex: '男' } // bad switch (age) { case 18 : break; default :break; } let obj = { name:'Tusi', sex :'男' } 花括号风格 【强制】控制语句或声明语句中，开始花括号应处于第一行，内容另起一行，结束花括号另起一行。 // 'brace-style': [2, '1tbs', { allowSingleLine: true }] // good function login() { if (bool) { // do something } else { // do something } } // bad function login() { if (bool) { // do something } else { // do something } } 注释 【建议】使用合理的注释来解释代码，提高可读性，如单行注释，多行注释，jsdoc注释。 最佳实践 禁止扩展原生对象 no-extend-native 【强制】除了团队内部明确的shim外，其他情况禁止扩展原生对象。 禁止使用eval, with no-eval, no-implied-eval, no-with 【强制】eval是不安全的。with性能并不具备优势，并且有语义不明的风险。 禁止出现alert, confirm, prompt no-alert 【强制】禁止出现alert, confirm, prompt，应使用自定义的UI组件来完成上述交互。 只遍历自身属性 【强制】在使用 for in 遍历对象时，使用hasOwnProperty判断是否为自身属性，防止遍历原型属性。 // \"guard-for-in\": 2 // good for (key in obj) { if (obj.hasOwnProperty(key)) { doSomething(key); } } // bad for (key in obj) { doSomething(key); } 推荐使用三等于 【建议】使用类型安全的 === 和 !== 操作符代替 == 和 != 操作符，除非你明确你的逻辑没有问题！ // 'eqeqeq': [2, 'allow-null'] // good let isTrue = bool === true // bad let isTrue = maybeBool == true 禁止使用魔术数字 no-magic-numbers 【建议】魔术数字是指代码中多次出现的没有明确含义的数字，它最好由命名常量取代，否则可能不易理解。 var gitalk = new Gitalk({ clientID: \"abe61bb2112d4926d0b9\", clientSecret: \"760737a207de2813a6586e1d2c14dd187ddeea64\", repo: \"FE-guide\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "},"Vue编码规范.html":{"url":"Vue编码规范.html","title":"Vue编码规范","keywords":"","body":"概述 本文根据生产实践和一些行业内的规范，总结了适合前端团队的vue编码风格，为团队成员提供编码风格标准和参考依据，规则不是固定的，最终以实际项目中lint规则为准！ 目录结构 按照项目实际运作情况，总结出前端项目目录结构及文件命名规范。 vue源代码统一放置于/src目录下，结构如下： ├─App.vue ├─main.js │ ├─api API封装和适配 │ ├─api.js │ │ │ ├─base │ │ │ ├─eqp │ │ │ └─user │ ├─assets 图片字体等资源 │ ├─fonts │ │ │ └─image │ ├─authority 处理动态路由权限 │ ├─generate-routes.js │ ├─route-map.js │ ├─components 自定义组件 │ ├─index.js │ ├─directives 自定义指令 │ ├─dialog-drag.js │ ├─index.js │ ├─icons SVG图标 │ ├─index.js │ │ │ └─svg │ ├─history.svg │ ├─mock 接口模拟 │ ├─bsj.js │ ├─index.js │ │ │ ├─eqp │ │ └─truck │ │ ├─index.js │ │ │ └─user │ └─menu │ ├─index.js │ ├─router 路由 │ ├─404.js │ ├─base-url.js │ ├─common.js │ ├─index.js │ │ │ └─modules │ └─test │ ├─index.js │ ├─store 状态管理 │ ├─index.js │ │ │ └─modules │ ├─user.js │ ├─styles 样式 │ ├─index.scss │ │ │ ├─global 全局样式 │ │ ├─common.scss 公共样式 │ │ ├─element-ui.scss ElementUI定制样式 │ │ ├─element-variables.scss 重设ElementUI默认的scss变量 │ │ ├─iconfont.scss 字体图标 │ │ ├─index.scss 引入同目录下的其他scss │ │ ├─layouts.scss 布局样式 │ │ ├─mixins.scss 维护mixin │ │ ├─reset.scss 重设浏览器自带样式，保证各浏览器基本风格一致 │ │ ├─variables.scss 维护scss变量 │ │ │ └─scoped 局部样式 │ ├─login.scss │ ├─utils 工具集 │ ├─helper.js │ └─views 页面 ├─404 │ ├─index.vue │ views目录下是项目的所有页面级vue文件，基本的原则是按照路由层级，结合功能特性，分模块书写。截取了一部分为例说明。 ├─404 一级路由 │ ├─index.vue │ ├─backend 一级路由 │ ├─index.vue │ │ │ ├─cloud-platform 二级路由 │ │ ├─index.vue │ │ │ │ │ ├─department 三级路由 │ │ │ │ │ ├─device 这单纯是一个目录，只是为了对齐业务设计，将云盒，云环，控制器等类似功能放在同一个目录归类 │ │ │ ├─cloud-box 三级路由 │ │ │ │ │ │ │ └─controller 三级路由 │ │ │ │ ├─datacenter 二级路由 │ │ ├─login 一级路由 │ ├─index.vue │ 文件夹及文件命名 统一使用kebab-case（短横线）命名法来命名文件夹及文件，见前端项目目录结构及文件命名规范。 命名规范 组件命名 【强制】如上文所述，vue组件文件命名采用kebab-case（短横线）命名法，如icon-font.vue。 【强制】给组件设置name属性时，应采用大驼峰写法，如name: 'IconFont'，对应规则vue/name-property-casing 【强制】使用组件时，应遵循以下规则： 导入组件 // 导入的变量名应为大驼峰写法 import EditUser from \"./edit-user.vue\"; 声明组件 components: { EditUser } 模板中使用 template 参照HTML编码规范，并结合以下规则。 script 参照Javascript编码规范即可。 style 参照CSS编码规范即可。 代码风格 缩进 以4空格缩进为准，参照Javascript编码规范即可。 组件书写规范 vue组件一般分为三部分，template, script, style，各部分之间应有空行分隔。 vue组件代码书写顺序如下： // \"vue/order-in-components\" export default { // 组件依赖声明 components: {}, // 外部输入属性 props: {}, // 实例数据 data() { return {} }, // 计算属性 computed: {}, // 侦听属性 watch: {}, // 生命周期，按顺序写 beforeCreate() {}, created() {}, beforeMount() {}, mounted() {},, beforeUpdate() {}, updated() {}, beforeDestroy() {}, destroyed() {}, // 实例方法 methods: {}, // 实例指令 directives: {}, // 实例过滤器 filters: {} } template // TODO script 参照Javascript编码规范即可。 style // TODO 最佳实践 template 标签自闭合 【建议】当组件标签内未包含内容时，应采用自闭合写法。 // good // bad v-if与v-for 【强制】禁止在同一标签上使用v-if与v-for prop写法 【建议】组件声明prop时，采用小驼峰写法；绑定时，应采用kebab-case（短横线）命名法。 // vue/prop-name-casing // good // 声明 props: { userName: { type: String } } // 绑定 prop与event绑定 【建议】采用简写形式绑定，:绑定属性，@绑定事件，对应规则vue/v-bind-style, vue/v-on-style 多属性绑定 【建议】当组件的属性或事件绑定大于3个时，应分行书写，一行一个。 // \"vue/max-attributes-per-line\": [2, { \"singleline\": 3 }] // good // bad 属性绑定编写顺序 DEFINITION：is LIST_RENDERING：v-for CONDITIONALS：v-if, v-else-if, v-else, v-show, v-cloak RENDER_MODIFIERS：v-once, v-pre GLOBAL：id UNIQUE：ref, key, v-slot, slot TWO_WAY_BINDING：v-model OTHER_DIRECTIVES：v-custom-directive OTHER_ATTR：custom-prop EVENTS：@eventName=\"eventHandler\" CONTENT：v-text, v-html this 【强制】不要在template中使用this访问vue实例属性或方法，因为默认已经绑定了this。对应规则vue/this-in-template 事件处理器 【强制】如果@绑定的事件处理器不带参数，则禁止在方法名后加括号。对应规则vue/v-on-function-call script prop类型 【强制】必须指定prop的类型，使用对应类型的构造函数而非字符串 // vue/require-prop-types // good props: { value: { type: String } } // bad props: { value: { type: 'String' } } prop默认值 【建议】给prop指定默认值default 【强制】Array和Object类型的prop，在指定默认值时，应使用函数返回默认值，而非字面量。 // good props: { options: { type: Object, default: function() { return {} } } } // bad props: { value: { type: 'String', default: {} } } 重复属性名 【强制】禁止在data, props, computed, methods等出现重复的属性名 // bad props: { propName: String }, data: { propName: null }, methods: { propName () {} } 保留关键字 【强制】禁止在给vue实例定义属性或方法时出现vue保留的一些关键字，如$el, $parent, $refs, $nextTick等。 计算属性 【强制】禁止在计算属性计算方法中，改变其依赖值。 // bad computed: { fullName () { this.firstName = 'Tusi' // 错误地改变了依赖值 return `${this.firstName} ${this.lastName}` } } style // TODO var gitalk = new Gitalk({ clientID: \"abe61bb2112d4926d0b9\", clientSecret: \"760737a207de2813a6586e1d2c14dd187ddeea64\", repo: \"FE-guide\", owner: \"cumt-robin\", admin: [\"cumt-robin\"], id: decodeURIComponent(location.pathname) }); gitalk.render(\"gitalk-container\"); "}}